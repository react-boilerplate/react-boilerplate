#! /bin/bash
#
# Functions for testing Bats assertions
#
# `expect_assertion_success` and `expect_assertion_failure` will validate that
# a Bats assertion function complies with the expectations outlined in
# `$_GO_CORE_DIR/lib/bats/assertions`, namely that it:
#
# - begins with `set "$DISABLE_BATS_SHELL_OPTIONS"`
# - calls `restore_bats_shell_options` directly via every return path
#
# They also enforce that the assertion produces no output when successful, and
# that it writes only to standard error (`>&2`) when it fails.
#
# You must set `ASSERTION_SOURCE` as the path to the file containing the
# assertions to test before sourcing this file. This file will then source
# `ASSERTION_SOURCE` for you (e.g. from `$_GO_CORE_DIR/tests/assertions.bats`):
#
#   ASSERTION_SOURCE="$_GO_CORE_DIR/lib/bats/assertions"
#   load "$_GO_CORE_DIR/lib/bats/assertion-test-helpers"
#
# You can use `printf_with_error` to simulate a failing script or function. For
# assertions that inspect file output, use `printf_to_test_output_file` to write
# to `TEST_OUTPUT_FILE`. See the comments for each function for more details.

if [[ -z "$ASSERTION_SOURCE" ]]; then
  printf '"ASSERTION_SOURCE" must be set before sourcing %s.\n' \
    "${BASH_SOURCE[0]}" >&2
  exit 1
fi

. "$ASSERTION_SOURCE"

# Temp directory for assertion test artifacts.
#
# Defined the same as `BATS_TEST_ROOTDIR` from `lib/bats/helpers`, but not
# dependent on it, so this file remains self-contained.
export ASSERTION_TEST_ROOTDIR="${BATS_TEST_ROOTDIR:-$BATS_TMPDIR/test rootdir}"

# This is the file written to by `printf_to_test_output_file`.
export TEST_OUTPUT_FILE="$ASSERTION_TEST_ROOTDIR/test-output.txt"

# Path to the script generated by `expect_assertion_*` to test whether
# `restore_bats_shell_options` was called or not.
readonly ASSERTION_TEST_SCRIPT="$ASSERTION_TEST_ROOTDIR/assertion-test.bats"

# Format for the error message emitted when `ASSERTION_TEST_SCRIPT` fails.
# Should be called as:
#   printf "$ASSERTION_TEST_SCRIPT_FAILURE_MESSAGE\n" "${assertion%% *}" >&2
export ASSERTION_TEST_SCRIPT_FAILURE_MESSAGE=

# Avoid exiting with an error on EOF with `!`.
! read -rd '' ASSERTION_TEST_SCRIPT_FAILURE_MESSAGE <<END_OF_FAILURE_MESSAGE
The very first line of '%s' must be

  set "\$DISABLE_BATS_SHELL_OPTIONS"

and it must call 'restore_bats_shell_options' directly from every return path.

For details, see the comments for 'restore_bats_shell_options' from:

  ${BASH_SOURCE%/*}/assertions
END_OF_FAILURE_MESSAGE

# Validates that an assertion succeeds for the provided inputs
#
# Will execute the command and assertion directly using the `run` command to
# make sure the condition is satisfied as expected, then it will execute them
# in a test script to make sure the assertion calls `set
# "$DISABLE_BATS_SHELL_OPTIONS` and `restore_bats_shell_options` appropriately.
#
# Arguments:
#   run_cmd:    The full command to pass to `run` as a single string
#   assertion:  The full assertion to evaluate as a single string
expect_assertion_success() {
  set +eET
  __expect_assertion_success "$@"
  __return_from_expect_assertion "$?"
}

# Validates that an assertion fails for the provided inputs
#
# Will execute the command and assertion directly using the `run` command to
# make sure the condition fails and the output is as expected, then it will
# execute them in a test script to make sure the assertion calls `set
# "$DISABLE_BATS_SHELL_OPTIONS` and `restore_bats_shell_options` appropriately.
#
# Arguments:
#   run_cmd:    The full command to pass to `run` as a single string
#   assertion:  The full assertion to evaluate as a single string
#   expected:   The expected output of the assertion failure
expect_assertion_failure() {
  set +eET
  __expect_assertion_failure "$@"
  __return_from_expect_assertion "$?"
}

# Calls `printf` on its arguments and returns an error
#
# Useful for generating some output and a failing status. Exported to make it
# available to generated test scripts.
#
# Globals:
#   PRINTF_ERROR:  If set, the function returns this value instead of 1
#
# Arguments:
#   ...:  Arguments to `printf`
printf_with_error() {
  printf "$@"
  return "${PRINTF_ERROR:-1}"
}
export -f printf_with_error

# Execute `printf` and write result to `TEST_OUTPUT_FILE`
#
# Since we can't really redirect output as part of an `expect_assertion_success`
# or `expect_failure` argument (it redirects the output from `eval run
# $run_cmd`), this encapsulates the redirection to `TEST_OUTPUT_FILE`.
#
# This function and `TEST_OUTPUT_FILE` are exported to make them available to
# generated test scripts. You can load `output` with the contents of the file
# using `set_bats_output_and_lines_from_file` from
# `$_GO_CORE_DIR/lib/bats/assertions`.
#
# Arguments:
#   ...:  Arguments to `printf`
printf_to_test_output_file() {
  if [[ ! -d "$ASSERTION_TEST_ROOTDIR" ]]; then
    mkdir "$ASSERTION_TEST_ROOTDIR"
  fi
  printf "$@" >"$TEST_OUTPUT_FILE"
}
export -f printf_to_test_output_file

# --------------------------------
# IMPLEMENTATION - HERE BE DRAGONS
#
# None of the functions below this line are part of the public interface.
# --------------------------------

# Implementation for `expect_assertion_success`
#
# Arguments:
#   run_cmd:    The full command to pass to `run` as a single string
#   assertion:  The full assertion to evaluate as a single string
__expect_assertion_success() {
  local run_cmd="$1"
  local assertion="$2"
  local test_script="$ASSERTION_TEST_SCRIPT"
  local __assertion_output
  local __assertion_status
  local expected_output=()

  if ! __run_command_and_assertion_in_subshell "$run_cmd" "$assertion"; then
    return '1'
  elif [[ "$__assertion_status" -ne '0' ]]; then
    printf "In subshell: expected passing status, actual %d\nOutput:\n%s\n" \
      "$__assertion_status" "$__assertion_output" >&2
    return '1'
  elif ! __check_expected_output "$__assertion_output"; then
    printf "'%s' should not produce output when successful.\n" \
      "${assertion%% *}" >&2
    return '1'
  fi

  # Although we expect the assertion under test to pass, this script injects a
  # failing assertion after it to check that the assertion under test directly
  # calls `restore_bats_shell_options` upon returning. If it doesn't, `set
  # -eET` will not be in effect, so the failing assertion will not trigger the
  # ERR trap or fail the test case.
  #
  # In an earlier incarnation of `restore_bats_shell_options` that only
  # restored `set -o functrace` (and when tests only started with `set +o
  # functrace`, equivalent to `set +T`), the failing assertion would fire the
  # ERR trap and exit the test case, but Bats would show the passing
  # assertion's stack, per issue #48.
  __run_assertion_test_script \
    "  run $run_cmd" \
    "  failing_assertion() { [ 0 -eq 1 ]; }" \
    "  $assertion" \
    "  failing_assertion"

  expected_output=('1..1'
    "not ok 1 $BATS_TEST_DESCRIPTION"
    "# (from function \`failing_assertion' in file $test_script, line 5,"
    "#  in test file $test_script, line 7)"
    "#   \`failing_assertion' failed")

  if ! __check_expected_output "$output" "${expected_output[@]}"; then
    printf "$ASSERTION_TEST_SCRIPT_FAILURE_MESSAGE" "${assertion%% *}" >&2
    return '1'
  fi
}

# Implementation for `expect_assertion_failure`
#
# Arguments:
#   run_cmd:    The full command to pass to `run` as a single string
#   assertion:  The full assertion to evaluate as a single string
#   expected:   The expected output of the assertion failure
__expect_assertion_failure() {
  local run_cmd="$1"
  local assertion="$2"
  shift 2
  local __assertion_output
  local __assertion_status
  local with_status
  local expected_output=()

  if ! __run_command_and_assertion_in_subshell "$run_cmd" "$assertion"; then
    return '1'
  elif [[ "$__assertion_status" -eq '0' ]]; then
    printf "In subshell: expected failure, but succeeded\nOutput:\n%s\n" \
      "$__assertion_output" >&2
    return '1'
  fi

  if [[ "$__assertion_status" -ne '1' ]]; then
    with_status=" with status $__assertion_status"
  elif ! __check_expected_output "$__assertion_output" "$@"; then
    return '1'
  fi

  __run_assertion_test_script "  run $run_cmd" "  $assertion"

  expected_output=('1..1'
    "not ok 1 $BATS_TEST_DESCRIPTION"
    "# (in test file $ASSERTION_TEST_SCRIPT, line 5)"
    "#   \`$assertion' failed${with_status}"
    "${@/#/# }")

  if ! __check_expected_output "$output" "${expected_output[@]}"; then
    printf "$ASSERTION_TEST_SCRIPT_FAILURE_MESSAGE" "${assertion%% *}" >&2
    return '1'
  fi
}

# Passes the target command to `run`, the executes the `assertion` in a subshell
#
# The `run_cmd` is executed in-process to set `output`, `status`, and `lines`.
#
# The `assertion` is executed in a process substitution (subshell) so that its
# __assertion_output and __assertion_status can be captured and evaluated while
# leaving `output`, `status`, and `lines` intact for later checks. It's also
# able to capture trailing blank lines in the assertion output, which `run
# $assertion` would normally remove.
#
# Globals:
#   __assertion_status:  Caller-declared variable for the assertion status
#   __assertion_output:  Caller-declared variable for the assertion output
#
# Arguments:
#   run_cmd:    The full command to pass to `run` as a single string
#   assertion:  The full assertion to evaluate as a single string
__run_command_and_assertion_in_subshell() {
  local run_cmd="$1"
  local assertion="$2"
  local line

  eval run $run_cmd
  while IFS= read -r line; do
    line="${line%$'\r'}"
    if [[ "$line" =~ ^exit:([0-9]+)$ ]]; then
      __assertion_status="${BASH_REMATCH[1]}"
    else
      __assertion_output+="$line"$'\n'
    fi
  done < <(trap 'echo exit:$?' EXIT; eval $assertion 3>&1 1>&- 2>&3; exit "$?")

  # Trim trailing newline to match typical `output` behavior.
  __assertion_output="${__assertion_output%$'\n'}"

  if [[ "$__assertion_output" =~ write\ error:\ Bad\ file\ descriptor$ ]]; then
    printf "'%s' tried to write to standard output instead of standard error" \
      "${assertion%% *}" >&2
    return 1
  elif [[ -z "$__assertion_status" ]]; then
    __assertion_output="${__assertion_output%exit:*}"

    if [[ "${FUNCNAME[1]}" == '__expect_assertion_failure' ]]; then
      printf '"%s" output does not end with a newline character:\n%s\n' \
        "${assertion%% *}" "${__assertion_output%exit:*}" >&2
      return 1
    fi
  fi
}

# Creates a test script from the arguments and runs it right away
#
# Arguments:
#   ...: Body of the test case to execute
__run_assertion_test_script() {
  local script_dir="${ASSERTION_TEST_SCRIPT%/*}"
  local script_impl=('#! /usr/bin/env bats'
    "load '$ASSERTION_SOURCE'"
    "@test \"$BATS_TEST_DESCRIPTION\" {"
    "$@"
    '}')

  if [[ ! -d "$script_dir" ]] && ! mkdir -p "$script_dir"; then
    printf 'Failed to create parent directory for assertion test script: %s\n' \
      "$ASSERTION_TEST_SCRIPT" >&2
    return '1'
  elif ! printf '%s\n' "${script_impl[@]}" >"$ASSERTION_TEST_SCRIPT"; then
    printf 'Failed to create assertion test script: %s\n' \
      "$ASSERTION_TEST_SCRIPT" >&2
    return '1'
  elif ! chmod 755 "$ASSERTION_TEST_SCRIPT"; then
    printf 'Failed to set permissions for assertion test script: %s\n' \
      "$ASSERTION_TEST_SCRIPT" >&2
    return '1'
  fi
  run "$ASSERTION_TEST_SCRIPT"
}

# Compares the actual assertion failure output against the expected output
#
# Arguments:
#   actual_output:  Actual assertion output as a single string
#   ...:            Expected assertion output as a series of strings
__check_expected_output() {
  local actual_output="$1"
  local expected_output=("${@:2}")
  local IFS=$'\n'
  expected_output="${expected_output[*]}"

  if [[ "$actual_output" != "$expected_output" ]]; then
    printf 'Actual output differs from expected output:\n' >&2
    printf -- '--------\nEXPECTED:\n%s\n--------\nACTUAL:\n%s\n--------\n' \
      "$expected_output" "$actual_output" >&2
    return 1
  fi
}

# Basically the same as `restore_bats_shell_options`, but specific to this file.
#
# Arguments:
#   result:  Return value of the calling assertion; defaults to 0
__return_from_expect_assertion() {
  local pattern=" expect_assertion_(success|failure) $BASH_SOURCE$"

  if [[ "${BATS_CURRENT_STACK_TRACE[0]}" =~ $pattern ]]; then
    unset 'BATS_CURRENT_STACK_TRACE[0]'
    set -eET
  fi
  return "${1:-0}"
}
